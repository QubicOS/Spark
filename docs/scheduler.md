# Планировщик и блокировки

SparkOS исполняет задачи как goroutine.
Ядро не планирует задачи само по себе: планирование и preemption обеспечиваются Go runtime.

## Fairness и ограничения

- “Справедливость” вычислений — ответственность задач (userland):
  - не держать горячие бесконечные циклы без блокировок;
  - использовать IPC/ожидание тиков для ожиданий и backoff;
  - при необходимости делать явный `runtime.Gosched()` внутри тяжёлых циклов (позже можно завернуть в helper).
- IPC-очереди на endpoint’ах FIFO, но доставка best-effort при переполнении.

## Блокировки

**Recv (IPC):**
- `Context.Recv` блокирует goroutine, если mailbox пуст.
- `Context.TryRecv` никогда не блокирует.
- Когда сообщение появляется в endpoint, получатель снимается с блокировки естественным образом (через канал).

**Tick-блокировка:**
- `Context.BlockOnTick` блокирует goroutine до следующего kernel tick.
- Tick в ядро доставляется вызовами `Kernel.TickTo(seq)` из “tick driver” — единственного потребителя `HAL.Time().Ticks()`.
- Это не “время” в смысле ОС: ядро не интерпретирует длительности, а лишь ретранслирует внешний счётчик тиков.

## Backpressure (очереди)

- Отправка (`SendTo*`/`SendCap*`) не блокирует.
- При переполнении mailbox отправка не доставляется: `SendErrQueueFull`.

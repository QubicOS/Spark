package shell

type escAction uint8

const (
	escNone escAction = iota
	escUp
	escDown
	escRight
	escLeft
	escDelete
	escHome
	escEnd
	escF1
	escF2
	escF3
)

func parseEscape(b []byte) (consumed int, action escAction, ok bool) {
	if len(b) == 0 || b[0] != 0x1b {
		return 0, escNone, true
	}
	if len(b) == 1 {
		// Treat bare ESC as a no-op key.
		return 1, escNone, true
	}
	if b[1] != '[' {
		// Treat unknown ESC sequences as a no-op ESC key.
		return 1, escNone, true
	}
	if len(b) < 3 {
		return 0, escNone, false
	}
	switch b[2] {
	case 'A':
		return 3, escUp, true
	case 'B':
		return 3, escDown, true
	case 'C':
		return 3, escRight, true
	case 'D':
		return 3, escLeft, true
	case 'H':
		return 3, escHome, true
	case 'F':
		return 3, escEnd, true
	case '3':
		// CSI 3 ~ : Delete.
		if len(b) < 4 {
			return 0, escNone, false
		}
		if b[3] == '~' {
			return 4, escDelete, true
		}
		return consumeEscape(b), escNone, true
	case '1':
		// CSI 1 ~ : Home.
		// CSI 11~ / 12~ / 13~ : F1/F2/F3 (as generated by termkbd).
		if len(b) < 4 {
			return 0, escNone, false
		}
		if b[3] == '~' {
			return 4, escHome, true
		}
		if len(b) >= 5 && b[4] == '~' {
			switch b[3] {
			case '1':
				return 5, escF1, true
			case '2':
				return 5, escF2, true
			case '3':
				return 5, escF3, true
			}
		}
		return consumeEscape(b), escNone, true
	case '4':
		// CSI 4 ~ : End.
		if len(b) < 4 {
			return 0, escNone, false
		}
		if b[3] == '~' {
			return 4, escEnd, true
		}
		return consumeEscape(b), escNone, true
	default:
		return consumeEscape(b), escNone, true
	}
}

func consumeEscape(b []byte) int {
	if len(b) < 2 || b[0] != 0x1b {
		return 0
	}
	if b[1] == '[' {
		for i := 2; i < len(b); i++ {
			if b[i] >= 0x40 && b[i] <= 0x7e {
				return i + 1
			}
		}
		return len(b)
	}
	return 2
}
